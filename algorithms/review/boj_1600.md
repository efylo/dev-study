## Review - BOJ 1600. 말이 되고픈 원숭이

### Abstract

- 2차원 배열 탐색
  - 좌상단 끝에서 시작하여, 우하단 끝까지의 경로를 탐색
  - 목적지까지의 최단 경로(이동의 횟수)를 구함
  - 탐색 간, 가능한 이동 방법의 수단이 둘
    - 체스의 폰(Pawn)
    - 체스의 나이트(Knight)
  - 나이트의 이동 방법은, 최대 이동 가능 횟수가 제한됨
  - 이동 불가능한 배열의 칸이 존재

---

### Wrong Approach

1. DP (DFS)
   - 점화식
     - f(r, c) = (r, c)에서 목적지까지의 최소 이동 횟수
     - f(목적지) = 0
   - 틀린 이유
     - (r, c)를 탐색했다고 해서, f(r, c)가 최소 이동 횟수임이 보장되지 않는다. 
     - 차후에 다른 경로를 통해서 (r, c)를 탐색하는 것이 최소 이동 횟수일 수 있다. 
   - 고찰
     - 방향성이 정해지지 않은 탐색의 경우, DFS를 활용한 DP를 차용하기 어렵다. 
     - 예)
       - (2, 1)만큼 이동 이후 (2, -1)만큼 이동하는 것
       - (1, 0)만큼 4번 이동하는 것
       - 하나의 이동을 먼저 진행할 경우, 다른 이동은 후에 고려되기 때문에, 처리가 어렵다. 
2. BFS - 2차원
   - 이동 방식(나이트, 폰)을 고려하지 않은 BFS
     - 예)
       - 나이트의 이동 방식을 이용하여 (2, 1) 좌표에 도달하는 것
       - 폰의 이동 방식을 이용하여 (2, 1) 좌표에 도달하는 것
     - 설명
       - 위 두 방식은, 마치 같은 상태처럼 보이지만 그렇지 않다. 
       - 나이트의 이동 방식은, (2, 1)의 좌표에 나이트의 이동을 1번 활용하여 도달한 것
       - 폰의 이동 방식은, (2, 1)의 좌표에 폰의 이동을 3번 활용하여 도달한 것
     - 이유
       - 중간에 장애물이 존재할 수 있고, 나이트는 이를 뛰어넘을 수 있다. 
       - 나이트는 최대 이동 횟수가 존재한다. 
         - 탐색의 중간 지점에서 장애물을 건너뛰어야 하는 경우를 포함하지 못한다. 
     - 이해
       - 나이트의 이동 횟수를 고려하여 각 노드를 설정하는 것이 바람직하다. 
         - (2, 1, 1) / (2, 1, 0)의 방식으로 위의 예시를 표현할 수 있다. 

---

### Approach

- 2차원 배열 탐색 간 다양한 이동 수단이 존재하는 경우의 문제
  - 이동 수단에 제약 사항 / 차별점이 존재하지 않는 경우
    - 2차원 BFS를 통해 해결 가능
  - 이동 수단에 제약 사항 / 차별점 존재하는 경우
    - 둘 이상의 이동 수단을, 다른 축으로 생각하여 푸는 것이 적절
    - 현 문제) 나이트의 최대 이동 가능 횟수, 이동 방법의 차이(장애물)

---

### Reference

- https://www.acmicpc.net/problem/1600